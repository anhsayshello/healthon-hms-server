generator client {
  provider = "prisma-client-js"
   previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  NURSE
  DOCTOR
  LAB_TECHNICIAN
  PATIENT
  CASHIER
}

enum Status {
  ACTIVE 
  INACTIVE
  DORMANT
}

enum JobType {
  FULL 
  PART
}

enum Gender {
  MALE
  FEMALE
}

enum AppointmentStatus  {
  PENDING 
  SCHEDULED
  CANCELLED
  COMPLETED
}

enum LabTestStatus  {
  PENDING 
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Weekday {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum Currency {
  VND
  USD
  EUR
}

enum PaymentMethod {
  CASH
  CARD
  BANK_TRANSFER
}

enum PaymentStatus {
  PAID
  UNPAID
}

model Patient {
  uid                      String            @id
  first_name               String
  last_name                String
  date_of_birth            DateTime
  gender                   Gender            @default(MALE)
  email                    String            @unique
  phone                    String
  marital_status           String
  address                  String
  emergency_contact_name   String
  emergency_contact_number String
  relation                 String
  blood_group              String?
  allergies                String?
  medical_conditions       String?
  medical_history          String?
  insurance_provider       String?
  insurance_number         String?
  privacy_consent          Boolean
  service_consent          Boolean
  medical_consent          Boolean
  photo_url                String?

  appointments             Appointment[]
  medical_records          MedicalRecord[]
  payments                 Payment[]

  created_at                DateTime          @default(now())
  updated_at                DateTime          @updatedAt
}

model Doctor {
  uid                      String            @id
  email                    String            @unique
  first_name               String
  last_name                String
  specialization           String
  license_number           String
  phone                    String
  address                  String
  department               String?
  photo_url                String?
  availability_status       String?

  type                     JobType @default(FULL)
  working_days             WorkingDays[]
  appointments             Appointment[]
  diagnoses                Diagnosis[]
  medical_records          MedicalRecord[]
  
  created_at                DateTime          @default(now())
  updated_at                DateTime          @updatedAt
}

model WorkingDays {
  id                       Int @id @default(autoincrement())
  doctor_id                String
  day                      Weekday
  start_time               String
  close_time               String

  doctor    Doctor  @relation(fields: [doctor_id], references: [uid], onDelete: Cascade)
  
  created_at                DateTime          @default(now())
  updated_at                DateTime          @updatedAt
}

model Staff {
  uid                      String            @id
  email                    String            @unique
  first_name               String
  last_name                String
  phone                    String
  address                  String
  department               String?
  license_number           String?
  photo_url                String?

  role                     Role
  status                   Status @default(ACTIVE)

  lab_tests                LabTest[]

  created_at                DateTime          @default(now())
  updated_at                DateTime          @updatedAt
}

model Appointment {
  id               Int              @id @default(autoincrement())
  patient_id       String
  doctor_id        String
  appointment_date DateTime
  time             String
  status           AppointmentStatus    @default(PENDING)
  type             String
  note             String?
  reason           String?

  patient          Patient          @relation(fields: [patient_id], references: [uid], onDelete: Cascade)
  doctor           Doctor           @relation(fields: [doctor_id], references: [uid], onDelete: Cascade)

  payment          Payment?
  medical_records          MedicalRecord[]

  created_at       DateTime         @default(now())
  updated_at       DateTime         @updatedAt
}

model Payment {
  id              Int               @id   @default(autoincrement())
  patient_id      String
  appointment_id  Int               @unique
  bill_date       DateTime
  payment_date    DateTime?
  discount        Float          @default(0)
  total_amount    Float
  amount_paid     Float

  payment_method  PaymentMethod     @default(CASH)
  status          PaymentStatus     @default(UNPAID)
  receipt_number  String               @unique @default(cuid()) 

  appointment     Appointment           @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  patient         Patient               @relation(fields: [patient_id], references: [uid], onDelete: Cascade)
  lab_bills       LabBill[]         
  prescription_bills PrescriptionBill[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model LabBill {
  id            Int       @id @default(autoincrement())
  payment_id       Int
  service_id    Int
  service_date  DateTime
  quantity      Int 
  unit_cost     Float
  total_cost    Float

  service Service        @relation(fields: [service_id], references: [id])
  payment Payment         @relation(fields: [payment_id], references: [id], onDelete: Cascade)

  created_at    DateTime  @default(now())
  updated_at    DateTime  @updatedAt
}

model Service {
  id           Int           @id @default(autoincrement())
  service_name String         @unique
  description  String
  price        Float
  currency     Currency    @default(VND)

  lab_tests      LabTest[]
  lab_bills      LabBill[]

  created_at   DateTime      @default(now())
  updated_at   DateTime      @updatedAt
}

model LabTest {
  id             Int       @id @default(autoincrement())
  service_id     Int      
  medical_record_id     Int
  technician_id  String?
  test_date      DateTime
  result         String?
  status         LabTestStatus  @default(PENDING) 
  notes          String?

  service         Service  @relation(fields: [service_id], references: [id])
  medical_record  MedicalRecord @relation(fields: [medical_record_id], references: [id], onDelete: Cascade)
  technician      Staff?    @relation(fields: [technician_id], references: [uid])

  created_at     DateTime  @default(now())
  updated_at     DateTime  @updatedAt

  @@unique([service_id, medical_record_id])
}

model MedicalRecord {
  id             Int          @id @default(autoincrement())
  patient_id     String
  appointment_id Int
  doctor_id      String
  treatment_plan String?
  lab_request    String?
  notes          String?

  appointment    Appointment  @relation(fields: [appointment_id], references: [id], onDelete: Cascade)
  doctor         Doctor       @relation(fields: [doctor_id], references: [uid], onDelete: Cascade)
  patient        Patient      @relation(fields: [patient_id], references: [uid], onDelete: Cascade)

  lab_tests       LabTest[]
  vital_signs    VitalSigns[]
  diagnoses      Diagnosis[]
  prescriptions  Prescription[]

  created_at     DateTime     @default(now())
  updated_at     DateTime     @updatedAt
}

model VitalSigns {
  id                Int             @id @default(autoincrement())
  medical_record_id        Int
  body_temperature  Float
  systolic          Int
  diastolic         Int
  heart_rate        Int
  respiratory_rate  Int?
  oxygen_saturation  Int?
  weight            Float
  height            Float

  medical_record    MedicalRecord  @relation(fields: [medical_record_id], references: [id], onDelete: Cascade)

  created_at        DateTime        @default(now())
  updated_at        DateTime        @updatedAt
}

model Diagnosis {
  id                       Int             @id @default(autoincrement())
  medical_record_id        Int
  doctor_id                String
  symptoms                 String
  diagnosis                String
  notes                    String?
  follow_up_plan           String?

  doctor                   Doctor          @relation(fields: [doctor_id], references: [uid])
  medical_record                  MedicalRecord  @relation(fields: [medical_record_id], references: [id], onDelete: Cascade)

  created_at               DateTime        @default(now())
  updated_at               DateTime        @updatedAt
}

model Medication {
  id             Int       @id @default(autoincrement())
  medication_name String    @unique
  description    String?
  unit_price     Float     
  currency       Currency    @default(VND)
  unit_type      String    
  manufacturer   String?
  stock_quantity Int       @default(0) 
  
  prescriptions     Prescription[]
  
  created_at     DateTime  @default(now())
  updated_at     DateTime  @updatedAt
}

model Prescription {
  id             Int             @id @default(autoincrement())
  medical_record_id     Int
  medication_id  Int             
  quantity       Int             
  dosage         String
  frequency      String
  duration       String
  instructions   String?

  medical_record MedicalRecord   @relation(fields: [medical_record_id], references: [id], onDelete: Cascade)
  medication     Medication      @relation(fields: [medication_id], references: [id]) 

  created_at     DateTime        @default(now())
  updated_at     DateTime        @updatedAt
}

model PrescriptionBill {
  id            Int       @id @default(autoincrement())
  payment_id       Int
  prescription_id Int
  quantity      Int 
  unit_cost     Float
  total_cost    Float

  prescription  Prescription    @relation(fields: [prescription_id], references: [id])
  payment       Payment         @relation(fields: [payment_id], references: [id], onDelete: Cascade)

  created_at    DateTime  @default(now())
  updated_at    DateTime  @updatedAt
}


model AuditLog {
  id      Int   @id @default(autoincrement())
  user_id        String
  record_id      String
  action         String
  details         String?
  model          String

  created_at     DateTime      @default(now())
  updated_at     DateTime      @updatedAt
}
